using System.Collections.Immutable;
using TestDataForTestDataFactoryGenerator.Boundaries.Served;

namespace TestDataForTestDataFactoryGenerator;

/// <summary>
/// This class was auto generated using TestDataFactoryGenerator, for following types:<br/>
/// - <see cref="TestDataForTestDataFactoryGenerator.Boundaries.Served.Order"/><br/>
/// This class can be edited, but it is preferable to not touch this file, and extend the partial class in a separate file.
/// </summary>
internal partial class OrderTestDataFactory
{
    private static readonly IImmutableList<int> _zeroBiasedCounts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2];

    private int GetZeroBiasedCount() => _zeroBiasedCounts.OrderBy(_ => _random.Next()).First();

    private readonly Random _random;

    public OrderTestDataFactory()
    {
        _random = new Random();
    }

    public OrderTestDataFactory(int seed)
    {
        _random = new Random(seed);
    }

    public OrderTestDataFactory(Random random)
    {
        _random = random;
    }

    public Order GenerateOrder(
        Guid? orderId = null,
        DateTimeOffset? orderDate = null,
        IImmutableSet<Position>? positions = null)
    {
        return new Order(
            OrderId: orderId ?? _random.NextGuid(),
            OrderDate: orderDate ?? _random.NextDateTimeOffset(),
            Positions: positions ?? Enumerable.Range(1, _random.Next(0, GetZeroBiasedCount())).Select(_ => GeneratePosition()).ToImmutableHashSet());
    }

    public Position GeneratePosition(
        Guid? positionId = null,
        Guid? productId = null,
        int? count = null,
        OptionalRef<PositionNote> positionNote = default,
        OptionalValue<int> batchSize = default)
    {
        return new Position(
            PositionId: positionId ?? _random.NextGuid(),
            ProductId: productId ?? _random.NextGuid(),
            Count: count ?? _random.Next(),
            PositionNote: positionNote.Unwrap(whenAutoGenerated: () => GeneratePositionNote()),
            BatchSize: batchSize.Unwrap(whenAutoGenerated: () => _random.Next()));
    }

    public PositionNote GeneratePositionNote(
        string? note = null)
    {
        return new PositionNote(
            Note: note ?? _random.NextString(""));
    }
}

internal class NullObject
{
    public static readonly NullObject Instance = new();

    private NullObject()
    {
    }
}

internal enum Option
{
    AutoGenerated = 1,
    Null = 2,
}

internal struct OptionalRef<T> where T : class
{
    private readonly T? _value;

    private readonly InternalOption _type = InternalOption.AutoGenerated;

    public OptionalRef(T value)
    {
        _value = value;
        _type = InternalOption.SpecifiedValue;
    }

    public OptionalRef(Option opt)
    {
        _value = default;
        _type = opt switch
        {
            Option.Null => InternalOption.Null,
            Option.AutoGenerated => InternalOption.AutoGenerated,
            _ => throw new NotImplementedException($"Can not handle {opt}"),
        };
    }

    public static implicit operator OptionalRef<T>(T value)
    {
        return new OptionalRef<T>(value);
    }

    public static implicit operator OptionalRef<T>(Option type)
    {
        return new OptionalRef<T>(type);
    }

    public T? Unwrap(Func<T> whenAutoGenerated)
    {
        return _type switch
        {
            InternalOption.SpecifiedValue => _value,
            InternalOption.Null => null,
            InternalOption.AutoGenerated => whenAutoGenerated(),
            _ => throw new InvalidOperationException(),
        };
    }

    private enum InternalOption
    {
        AutoGenerated = 0,
        SpecifiedValue = 1,
        Null = 2,
    }
}

internal struct OptionalValue<T> where T : struct
{
    private readonly T? _value;

    private readonly InternalOption _type = InternalOption.AutoGenerated;

    public OptionalValue(T value)
    {
        _value = value;
        _type = InternalOption.SpecifiedValue;
    }

    public OptionalValue(Option opt)
    {
        _value = default;
        _type = opt switch
        {
            Option.Null => InternalOption.Null,
            Option.AutoGenerated => InternalOption.AutoGenerated,
            _ => throw new NotImplementedException($"Can not handle {opt}"),
        };
    }

    public static implicit operator OptionalValue<T>(T value)
    {
        return new OptionalValue<T>(value);
    }

    public static implicit operator OptionalValue<T>(Option type)
    {
        return new OptionalValue<T>(type);
    }

    public T? Unwrap(Func<T> whenAutoGenerated)
    {
        return _type switch
        {
            InternalOption.SpecifiedValue => _value,
            InternalOption.Null => null,
            InternalOption.AutoGenerated => whenAutoGenerated(),
            _ => throw new InvalidOperationException(),
        };
    }

    private enum InternalOption
    {
        AutoGenerated = 0,
        SpecifiedValue = 1,
        Null = 2,
    }
}

internal static class RandomExtensions
{
    public static string NextString(this Random r, string? prefix) => $"{prefix ?? "RandomString"}_{r.Next(1, 1_000_000)}";

    public static byte[] NextBytes(this Random r, int length = 10)
    {
        byte[] bytes = new byte[16];
        r.NextBytes(bytes);
        return bytes;
    }

    public static Guid NextGuid(this Random r) => new Guid(r.NextBytes(16));

    public static DateTimeOffset NextDateTimeOffset(this Random r) =>  new DateTimeOffset(r.NextInt64(), TimeSpan.FromHours(r.Next(-23, 23)));

    public static TimeSpan NextTimeSpan(this Random r) => new TimeSpan(r.NextInt64());

    public static DateTime NextDateTime(this Random r) => new DateTime(r.Next(2000, 2100), r.Next(1, 13), r.Next(1, 28), r.Next(0, 23), r.Next(0, 59), r.Next(0, 59));

    public static bool NextBool(this Random r) => (r.Next(0, 1000) % 2) == 0;

    public static long NextLong(this Random r) => r.NextInt64();

    public static decimal NextDecimal(this Random r) => (decimal)r.NextDouble();
}