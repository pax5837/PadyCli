using System.Collections.Immutable;

using TestDataForTestDataFactoryGenerator.Served;

namespace TestDataForTestDataFactoryGenerator;

/// <summary>
/// This class was auto generated using TestDataFactoryGenerator, for following types:<br/>
/// - <see cref="TestDataForTestDataFactoryGenerator.Served.Delivery"/><br/>
/// - <see cref="TestDataForTestDataFactoryGenerator.Served.Order"/><br/>
/// This class can be edited, but it is preferable to not touch this file, and extend the partial class in a separate file.
/// </summary>
internal partial class OrderTestDataFactory
{
    private static readonly IImmutableList<int> _zeroBiasedCounts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2];

    private int GetZeroBiasedCount() => _zeroBiasedCounts.OrderBy(_ => _random.Next()).First();

    private readonly Random _random;

    public OrderTestDataFactory()
    {
        _random = new Random();
    }

    public OrderTestDataFactory(int seed)
    {
        _random = new Random(seed);
    }

    public OrderTestDataFactory(Random random)
    {
        _random = random;
    }

    public ContactInfo GenerateContactInfo()
    {
        return _random.Next(0, 2) switch {
            0 => GeneratePhoneContactInfo(),
            1 => GenerateEmailContactInfo(),
            _ => throw new InvalidOperationException("Unexpected constructor number"),
        };
    }

    public Delivery GenerateDelivery(
        IImmutableList<ItemPosition>? items = null,
        DateTimeOffset? deliveryDate = null)
    {
        return new Delivery(
            Items: items ?? Enumerable.Range(1, _random.Next(0, GetZeroBiasedCount())).Select(_ => GenerateItemPosition()).ToImmutableList(),
            DeliveryDate: deliveryDate ?? _random.NextDateTimeOffset());
    }

    public EmailContactInfo GenerateEmailContactInfo(
        Person? person = null,
        string? email = null)
    {
        return new EmailContactInfo(
            Person: person ?? GeneratePerson(),
            Email: email ?? _random.NextString(""));
    }

    public ItemPosition GenerateItemPosition(
        Guid? itemPositionId = null,
        Guid? productId = null,
        string? productShortName = null,
        int? itemCount = null,
        decimal? positionPrice = null)
    {
        return new ItemPosition(
            ItemPositionId: itemPositionId ?? _random.NextGuid(),
            ProductId: productId ?? _random.NextGuid(),
            ProductShortName: productShortName ?? _random.NextString(""),
            ItemCount: itemCount ?? _random.Next(),
            PositionPrice: positionPrice ?? _random.NextDecimal());
    }

    public Order GenerateOrder(
        Guid? orderId = null,
        DateTimeOffset? orderDate = null,
        IImmutableSet<Position>? position = null,
        ContactInfo? contactInfo = null,
        Delivery? delivery = null)
    {
        return new Order(
            OrderId: orderId ?? _random.NextGuid(),
            OrderDate: orderDate ?? _random.NextDateTimeOffset(),
            Position: position ?? Enumerable.Range(1, _random.Next(0, GetZeroBiasedCount())).Select(_ => GeneratePosition()).ToImmutableHashSet(),
            ContactInfo: contactInfo ?? GenerateContactInfo(),
            Delivery: delivery ?? GenerateDelivery());
    }

    public Person GeneratePerson(
        Guid? id = null,
        string? firstName = null,
        string? lastName = null)
    {
        return new Person(
            Id: id ?? _random.NextGuid(),
            FirstName: firstName ?? _random.NextString(""),
            LastName: lastName ?? _random.NextString(""));
    }

    public PhoneContactInfo GeneratePhoneContactInfo(
        Person? person = null,
        string? phoneNumber = null)
    {
        return new PhoneContactInfo(
            Person: person ?? GeneratePerson(),
            PhoneNumber: phoneNumber ?? _random.NextString(""));
    }

    public Position GeneratePosition(
        Guid? positionId = null,
        Guid? productId = null,
        int? count = null,
        OptionalRef<PositionNote> positionNote = default,
        OptionalValue<int> batchSize = default)
    {
        return new Position(
            PositionId: positionId ?? _random.NextGuid(),
            ProductId: productId ?? _random.NextGuid(),
            Count: count ?? _random.Next(),
            PositionNote: positionNote.Unwrap(whenAutoGenerated: () => GeneratePositionNote()),
            BatchSize: batchSize.Unwrap(whenAutoGenerated: () => _random.Next()));
    }

    public PositionNote GeneratePositionNote(
        string? note = null)
    {
        return new PositionNote(
            Note: note ?? _random.NextString(""));
    }
}

internal class NullObject
{
    public static readonly NullObject Instance = new();

    private NullObject()
    {
    }
}

internal enum Option
{
    AutoGenerated = 1,
    Null = 2,
}

internal struct OptionalRef<T> where T : class
{
    private readonly T? _value;

    private readonly InternalOption _type = InternalOption.AutoGenerated;

    public OptionalRef(T value)
    {
        _value = value;
        _type = InternalOption.SpecifiedValue;
    }

    public OptionalRef(Option opt)
    {
        _value = default;
        _type = opt switch
        {
            Option.Null => InternalOption.Null,
            Option.AutoGenerated => InternalOption.AutoGenerated,
            _ => throw new NotImplementedException($"Can not handle {opt}"),
        };
    }

    public static implicit operator OptionalRef<T>(T value)
    {
        return new OptionalRef<T>(value);
    }

    public static implicit operator OptionalRef<T>(Option type)
    {
        return new OptionalRef<T>(type);
    }

    public T? Unwrap(Func<T> whenAutoGenerated)
    {
        return _type switch
        {
            InternalOption.SpecifiedValue => _value,
            InternalOption.Null => null,
            InternalOption.AutoGenerated => whenAutoGenerated(),
            _ => throw new InvalidOperationException(),
        };
    }

    private enum InternalOption
    {
        AutoGenerated = 0,
        SpecifiedValue = 1,
        Null = 2,
    }
}

internal struct OptionalValue<T> where T : struct
{
    private readonly T? _value;

    private readonly InternalOption _type = InternalOption.AutoGenerated;

    public OptionalValue(T value)
    {
        _value = value;
        _type = InternalOption.SpecifiedValue;
    }

    public OptionalValue(Option opt)
    {
        _value = default;
        _type = opt switch
        {
            Option.Null => InternalOption.Null,
            Option.AutoGenerated => InternalOption.AutoGenerated,
            _ => throw new NotImplementedException($"Can not handle {opt}"),
        };
    }

    public static implicit operator OptionalValue<T>(T value)
    {
        return new OptionalValue<T>(value);
    }

    public static implicit operator OptionalValue<T>(Option type)
    {
        return new OptionalValue<T>(type);
    }

    public T? Unwrap(Func<T> whenAutoGenerated)
    {
        return _type switch
        {
            InternalOption.SpecifiedValue => _value,
            InternalOption.Null => null,
            InternalOption.AutoGenerated => whenAutoGenerated(),
            _ => throw new InvalidOperationException(),
        };
    }

    private enum InternalOption
    {
        AutoGenerated = 0,
        SpecifiedValue = 1,
        Null = 2,
    }
}

internal static class RandomExtensions
{
    public static string NextString(this Random r, string? prefix) => $"{prefix ?? "RandomString"}_{r.Next(1, 1_000_000)}";

    public static byte[] NextBytes(this Random r, int length = 10)
    {
        byte[] bytes = new byte[16];
        r.NextBytes(bytes);
        return bytes;
    }

    public static Guid NextGuid(this Random r) => new Guid(r.NextBytes(16));

    public static DateTimeOffset NextDateTimeOffset(this Random r) =>  new DateTimeOffset(r.NextInt64(), TimeSpan.FromHours(r.Next(-23, 23)));

    public static TimeSpan NextTimeSpan(this Random r) => new TimeSpan(r.NextInt64());

    public static DateTime NextDateTime(this Random r) => new DateTime(r.Next(2000, 2100), r.Next(1, 13), r.Next(1, 28), r.Next(0, 23), r.Next(0, 59), r.Next(0, 59));

    public static bool NextBool(this Random r) => (r.Next(0, 1000) % 2) == 0;

    public static long NextLong(this Random r) => r.NextInt64();

    public static decimal NextDecimal(this Random r) => (decimal)r.NextDouble();
}